let QueryValidationError = require('./query-validation-error');
let _ = require('lodash');
let objtools = require('zs-objtools');

/**
 * Encapsulates a common query and provides methods for utilizing and manipulating it.
 * Common queries are mongo-like queries that are largely compatible with mongodb
 * queries.
 *
 * This class should not be instantiated directly.  Instead, use QueryFactory.
 *
 * @class Query
 * @constructor
 * @param {Object} queryData - Raw object containing the query.
 * @param {QueryFactory} queryFactory - QueryFactory that created this query.
 */
class Query {

	constructor(queryData, queryFactory) {
		this._queryData = queryData;
		this._queryFactory = queryFactory;
		// Various properties set while matching an object, such as distance from a $near operator
		this._matchProperties = {};
	}

	/**
	 * Returns the query data this class encapsulates.
	 *
	 * @method getData
	 * @return {Object}
	 */
	getData() {
		return this._queryData;
	}

	/**
	 * Returns the query factory that created this query.
	 *
	 * @method getQueryFactory
	 * @return {QueryFactory}
	 */
	getQueryFactory() {
		return this._queryFactory;
	}

	/**
	 * Set a match property during a match.
	 *
	 * @method setMatchProperty
	 * @protected
	 * @param {String} name
	 * @param {Mixed} value
	 */
	setMatchProperty(name, value) {
		this._matchProperties[name] = value;
	}

	/**
	 * Gets a match property.  A match property is a value that is generated
	 * during the matching process that pertains to the document being matched.  An example
	 * is the 'distance' property generated by $near, and is useful for sorting by distance.
	 * Returned properties always pertain to the most recent match performed.
	 *
	 * @method getMatchProperty
	 * @param {String} name - Name of match property to fetch
	 * @return {Mixed}
	 */
	getMatchProperty(name) {
		return this._matchProperties[name];
	}

	/**
	 * Merges the match properties of otherQuery with the match properties of this query,
	 * overwriting any properties that conflict.
	 *
	 * @method _mergeMatchProperties
	 * @private
	 * @param {Query} otherQuery
	 */
	_mergeMatchProperties(otherQuery) {
		for (key in otherQuery._matchProperties) {
			this._matchProperties[key] = otherQuery._matchProperties[key];
		}
	}

	/**
	 * Returns whether or not the query matches a given value.
	 *
	 * @method matches
	 * @throws {XError} - Validation error
	 * @param {Object} value - The value to match against
	 * @return {Boolean} - Whether or not the query matches
	 */
	matches(value) {
		this._matchProperties = {};
		let query = this._queryData;
		let queryOperators = this._queryFactory._queryOperators;
		let exprOperators = this._queryFactory._exprOperators;
		if (!_.isPlainObject(query)) throw new QueryValidationError('Query must be a plain object');
		for (let key in query) {
			let exprValue = query[key];
			if (exprValue === undefined) continue;
			if (key[0] === '$') {
				// This key is a query operator or expression operator
				let queryOperator = queryOperators[key];
				if (queryOperator) {
					if (!queryOperator.matches(value, exprValue, key, this)) {
						return false;
					}
				} else {
					let exprOperator = exprOperators[key];
					if (exprOperator) {
						if (!exprOperator.matches(value, exprValue, key, query, this)) {
							return false;
						}
					} else {
						throw new QueryValidationError('Unrecognized query operator: ' + key);
					}
				}
			} else {
				// This key is a field name
				let fieldValue = objtools.getPath(value, key);
				if (!this._expressionValueMatches(fieldValue, exprValue)) {
					return false;
				}
			}
		}
		return true;
	}

	/**
	 * Checks to see if an operator expression or value exact match matches a value.
	 *
	 * @method _expressionValueMatches
	 * @private
	 * @throws {XError} - Validation error
	 * @param {Mixed} fieldValue - Value to match against
	 * @param {Mixed} exprValue - Operator expression, or exact match value
	 * @return {Boolean} - Whether or not the operator expression matches the value
	 */
	_expressionValueMatches(fieldValue, exprValue) {
		if (isOperatorExpression(exprValue)) {
			// Query expression is a set of expression operators
			return this._operatorExpressionMatches(fieldValue, exprValue);
		} else {
			// Query expression is an exact match
			if (exprValue === null && fieldValue === undefined) {
				// as per mongodb behavior
				return true;
			}
			if (Array.isArray(fieldValue)) {
				return _.some(fieldValue, elem => objtools.deepEquals(elem, exprValue) );
			} else {
				return objtools.deepEquals(fieldValue, exprValue);
			}
		}
	}

	/**
	 * Checks to see if an operator expression matches a value.
	 *
	 * @method _operatorExpressionMatches
	 * @private
	 * @throws {XError} - Validation error
	 * @param {Mixed} fieldValue - Value to match against
	 * @param {Mixed} exprValue - Operator expression, or exact match value
	 * @return {Boolean} - Whether or not the operator expression matches the value
	 */
	_operatorExpressionMatches(fieldValue, exprValue) {
		let exprOperators = this._queryFactory._exprOperators;
		for (let exprOperatorKey in exprValue) {
			let operatorValue = exprValue[exprOperatorKey];
			if (operatorValue === undefined) continue;
			let exprOperator = exprOperators[exprOperatorKey];
			if (!exprOperator) {
				throw new QueryValidationError('Unrecognized expression operator: ' + exprOperator);
			}
			if (!exprOperator.matches(fieldValue, operatorValue, exprOperatorKey, exprValue, this)) {
				return false;
			}
		}
		return true;
	}

	/**
	 * Executes a match of a subquery in the context of this query.
	 *
	 * @method _matchSubquery
	 * @private
	 * @param {Mixed} subqueryData - Data to create subquery with
	 * @param {Mixed} value - Value to match against
	 * @return {Boolean} - Does it match?
	 */
	_matchSubquery(subqueryData, value) {
		let subquery = this._queryFactory.createQuery(subqueryData);
		let doesItMatch = subquery.matches(value);
		this._mergeMatchProperties(subquery);
		return doesItMatch;
	}

	/**
	 * Returns a function that takes a value as a parameter and matches the query
	 * against the given value.  Right now, there is no real difference between using
	 * this and just calling match() on each value, but in the future, this may return
	 * a precompiled function that is able to do much faster matching.
	 *
	 * @method createMatchingFn
	 * @return {Function} - Function in the form function(value) which returns a boolean.
	 */
	createMatchingFn() {
		return value => this.matches(value);
	}

	/**
	 * Internal function to traverse a query tree.
	 *
	 * @method _traverse
	 * @private
	 * @param {Object} handlers - Set of handler functions for query entities.  Each of these
	 * is called with a 'this' pointer of the relevant operator.
	 * @param {Function} handlers.queryOperator - Called for each query operator
	 * @param {Mixed} handlers.queryOperator.exprValue - Value of the query operator key
	 * @param {String} handlers.queryOperator.operator - String name of the operator
	 * @param {Query} handlers.queryOperator.query - This query
	 * @param {Function} handlers.exprOperator - Called for each expression operator
	 * @param {Mixed} handlers.exprOperator.exprValue - Value of the expression operator key
	 * @param {String} handlers.exprOperator.field - Field expr operator applied to, or null (if at root)
	 * @param {String} handlers.exprOperator.operator - String name of the operator
	 * @param {Object} handlers.exprOperator.expr - The containing expression of the expression operator
	 * @param {Query} handlers.exprOperator.query - This query
	 * @param {Function} handlers.exactMatch - Function called for each exact match (called without a 'this')
	 * @param {Mixed} handlers.exactMatch.value - Exact match value
	 * @param {String} handlers.exactMatch.field - Exact match field
	 * @param {Function} handlers.query - Function that is called for the main query and any subqueries
	 * @param {Query} handlers.query.query - Query object for query or subquery
	 */
	_traverse(handlers) {
		let query = this._queryData;
		let queryOperators = this._queryFactory._queryOperators;
		let exprOperators = this._queryFactory._exprOperators;
		handlers.query(this);
		if (!_.isPlainObject(query)) throw new QueryValidationError('Query must be a plain object');
		for (let key in query) {
			let exprValue = query[key];
			if (exprValue === undefined) continue;
			if (key[0] === '$') {
				// This key is a query operator or expression operator
				let queryOperator = queryOperators[key];
				if (queryOperator) {
					handlers.queryOperator.call(queryOperator, exprValue, key, this);
					queryOperator.traverse(exprValue, key, this, handlers);
				} else {
					let exprOperator = exprOperators[key];
					if (exprOperator) {
						handlers.exprOperator.call(exprOperator, exprValue, null, key, query, this);
						exprOperator.traverse(exprValue, null, key, query, this, handlers);
					} else {
						throw new QueryValidationError('Unrecognized query operator: ' + key);
					}
				}
			} else {
				// This key is a field name
				this._traverseExpressionValue(exprValue, key, handlers);
			}
		}
	}

	_traverseExpressionValue(exprValue, field, handlers) {
		if (isOperatorExpression(exprValue)) {
			// Query expression is a set of expression operators
			this._traverseOperatorExpression(exprValue, field, handlers);
		} else {
			// It's an exact match
			handlers.exactMatch.call(null, exprValue, field);
		}
	}

	_traverseOperatorExpression(exprValue, field, handlers) {
		let exprOperators = this._queryFactory._exprOperators;
		for (let exprOperatorKey in exprValue) {
			let operatorValue = exprValue[exprOperatorKey];
			if (operatorValue === undefined) continue;
			let exprOperator = exprOperators[exprOperatorKey];
			if (!exprOperator) {
				throw new QueryValidationError('Unrecognized expression operator: ' + exprOperator);
			}
			handlers.exprOperator.call(exprOperator, operatorValue, field, exprOperatorKey, exprValue, this);
			exprOperator.traverse(operatorValue, field, exprOperatorKey, exprValue, this, handlers);
		}
	}

	_traverseSubquery(subqueryData, handlers) {
		let subquery = this._queryFactory.createQuery(subqueryData);
		subquery._traverse(handlers);
	}

	/**
	 * Validates that the encapsulated query is correct.
	 *
	 * @method validate
	 * @throws {XError} - Validation error
	 * @return {Boolean} - true
	 */
	validate() {
		this._traverse({
			queryOperator(exprValue, operator, query) {
				this.validate(exprValue, operator, query);
			},
			exprOperator(exprValue, field, operator, expr, query) {
				this.validate(exprValue, operator, expr, query);
			},
			exactMatch: _.noop,
			query: _.noop
		});
		return true;
	}

	/**
	 * Returns a list of fields (in dot-separated notation) that the query accesses.
	 *
	 * @method getQueriedFields
	 * @throws {XError} - Validation error
	 * @return {String[]} - Array of fields
	 */
	getQueriedFields() {

	}

	/**
	 * Adds queried fields to the given fieldSet.
	 *
	 * @method _getQueriedFields
	 * @private
	 * @throws {XError} - Validation error
	 * @param {Object} fieldSet - Map from string field name to boolean true.
	 */
	_getQueriedFields(fieldSet) {

	}

	/**
	 * Transforms queried fields according to a given transformation function.  Changes
	 * are made in-place.
	 *
	 * @method transformQueriedFields
	 * @throws {XError} - Validation error
	 * @param {Function} transformFn - Function that takes a field name and returns a
	 * transformed field name.
	 * @param {String} transformFn.name - Field name
	 */
	transformQueriedFields(transformFn) {

	}

	/**
	 * Returns information on exactly matched fields in the query.  Exactly matched fields
	 * are fields that must match a single, exact, scalar, non-null value for the query
	 * to match.  This function also returns a boolean that indicates whether there are
	 * any fields in the query that are not exact matches.
	 *
	 * @method getExactMatches
	 * @throws {XError} - Validation error
	 * @return {Object} - Object in the form: `{ exactMatches: {...}, onlyExactMatches: true|false }`
	 */
	getExactMatches() {

	}

	/**
	 * Adds exact matches to the given map.
	 *
	 * @method _getExactMatches
	 * @private
	 * @throws {XError} - Validation error
	 * @param {Object} exactMatches - Map from fields to values.  Values may be null, indicating
	 * that the field has no valid matching value at that the query will never match.
	 * @return {Boolean} - True if only exactly matching fields are present in the query.
	 */
	_getExactMatches(exactMatches) {

	}

	/**
	 * Returns a list of all operators used in the query.
	 *
	 * @method getOperators
	 * @throws {XError} - Validation error
	 * @return {String[]} - Array of all operators, such as `[ "$and", "$in" ]`
	 */
	getOperators() {

	}

	/**
	 * Adds all used operators to the operatorSet.
	 *
	 * @method _getOperators
	 * @private
	 * @throws {XError} - Validation error
	 * @param {Object} operatorSet - Map from operator string to true
	 */
	_getOperators(operatorSet) {

	}

	/**
	 * Substitutes $var expressions in the query with their corresponding values
	 * given as the parameter.  Substitution is done in-place.
	 *
	 * @method substituteVars
	 * @throws {XError} - Validation error, or missing var error
	 * @param {Object} vars - Mapping from variable names to values
	 * @param {Boolean} ignoreMissing - If set to true, exceptions are not thrown if
	 * a missing var name is encountered.
	 */
	substituteVars(vars, ignoreMissing) {

	}

}

module.exports = Query;

/**
 * Helper function to determine if a given expression is an operator expression in the
 * form { $gt: 12, $lt: 15 } or is an exact match.
 *
 * @param {Mixed} expr
 * @throws {XError} - Throws if expression is a mix of operators and non-operators
 * @return {Boolean} - True if expression contains operators
 */
function isOperatorExpression(expr) {
	let hasOperators = false;
	let hasNonOperators = false;
	for (let key in expr) {
		if (key[0] === '$') {
			hasOperators = true;
		} else {
			hasNonOperators = true;
		}
	}
	if (hasOperators && hasNonOperators) {
		throw new QueryValidationError('Expressions may not contain a mix of operators and non-operators');
	}
	return hasOperators;
}
