let QueryValidationError = require('./query-validation-error');
let MissingQueryVarError = require('./missing-query-var-error');
let _ = require('lodash');
let objtools = require('zs-objtools');

/**
 * Encapsulates a common query and provides methods for utilizing and manipulating it.
 * Common queries are mongo-like queries that are largely compatible with mongodb
 * queries.
 *
 * This class should not be instantiated directly.  Instead, use QueryFactory.
 *
 * @class Query
 * @constructor
 * @throws {XError} - If update is invalid
 * @param {Object} queryData - Raw object containing the query.
 * @param {QueryFactory} queryFactory - QueryFactory that created this query.
 * @param {Object} [options]
 * @param {String} [options.fieldPrefix] - If this is a subquery, the path to the parent field.
 * @param {String} [options.vars] - If this query contains $var statements, this is a map
 *   of $var values to their substitutions.
 */
class Query {

	constructor(queryData, queryFactory, options = {}) {
		this._queryData = queryData;
		this._queryFactory = queryFactory;
		this._fieldPrefix = options.fieldPrefix;
		// Various properties set while matching an object, such as distance from a $near operator
		this._matchProperties = {};

		if (options.vars) this._substituteVars(options.vars);
		this.validate();
	}

	/**
	 * Returns the query data this class encapsulates.
	 *
	 * @method getData
	 * @return {Object}
	 */
	getData() {
		return this._queryData;
	}

	/**
	 * Returns the query factory that created this query.
	 *
	 * @method getQueryFactory
	 * @return {QueryFactory}
	 */
	getQueryFactory() {
		return this._queryFactory;
	}

	/**
	 * Set a match property during a match.
	 *
	 * @method setMatchProperty
	 * @protected
	 * @param {String} name
	 * @param {Mixed} value
	 */
	setMatchProperty(name, value) {
		this._matchProperties[name] = value;
	}

	/**
	 * Gets a match property.  A match property is a value that is generated
	 * during the matching process that pertains to the document being matched.  An example
	 * is the 'distance' property generated by $near, and is useful for sorting by distance.
	 * Returned properties always pertain to the most recent match performed.
	 *
	 * @method getMatchProperty
	 * @param {String} name - Name of match property to fetch
	 * @return {Mixed}
	 */
	getMatchProperty(name) {
		return this._matchProperties[name];
	}

	/**
	 * Merges the match properties of otherQuery with the match properties of this query,
	 * overwriting any properties that conflict.
	 *
	 * @method _mergeMatchProperties
	 * @private
	 * @param {Query} otherQuery
	 */
	_mergeMatchProperties(otherQuery) {
		for (key in otherQuery._matchProperties) {
			this._matchProperties[key] = otherQuery._matchProperties[key];
		}
	}

	/**
	 * Returns whether or not the query matches a given value.
	 *
	 * @method matches
	 * @throws {XError} - Validation error
	 * @param {Object} value - The value to match against
	 * @return {Boolean} - Whether or not the query matches
	 */
	matches(value) {
		this._matchProperties = {};
		let query = this._queryData;
		let queryOperators = this._queryFactory._queryOperators;
		let exprOperators = this._queryFactory._exprOperators;
		if (!_.isPlainObject(query)) throw new QueryValidationError('Query must be a plain object');
		for (let key in query) {
			let exprValue = query[key];
			if (exprValue === undefined) continue;
			if (key[0] === '$') {
				// This key is a query operator or expression operator
				let queryOperator = queryOperators[key];
				if (queryOperator) {
					if (!queryOperator.matches(value, exprValue, key, this)) {
						return false;
					}
				} else {
					let exprOperator = exprOperators[key];
					if (exprOperator) {
						if (!exprOperator.matches(value, exprValue, key, query, this)) {
							return false;
						}
					} else {
						throw new QueryValidationError('Unrecognized query operator: ' + key);
					}
				}
			} else {
				// This key is a field name
				let fieldValue = objtools.getPath(value, key);
				if (!this._expressionValueMatches(fieldValue, exprValue)) {
					return false;
				}
			}
		}
		return true;
	}

	/**
	 * Checks to see if an operator expression or value exact match matches a value.
	 *
	 * @method _expressionValueMatches
	 * @private
	 * @throws {XError} - Validation error
	 * @param {Mixed} fieldValue - Value to match against
	 * @param {Mixed} exprValue - Operator expression, or exact match value
	 * @return {Boolean} - Whether or not the operator expression matches the value
	 */
	_expressionValueMatches(fieldValue, exprValue) {
		if (isOperatorExpression(exprValue)) {
			// Query expression is a set of expression operators
			return this._operatorExpressionMatches(fieldValue, exprValue);
		} else {
			// Query expression is an exact match
			if (exprValue === null && fieldValue === undefined) {
				// as per mongodb behavior
				return true;
			}
			if (Array.isArray(fieldValue)) {
				return _.some(fieldValue, elem => objtools.deepEquals(elem, exprValue) );
			} else {
				return objtools.deepEquals(fieldValue, exprValue);
			}
		}
	}

	/**
	 * Checks to see if an operator expression matches a value.
	 *
	 * @method _operatorExpressionMatches
	 * @private
	 * @throws {XError} - Validation error
	 * @param {Mixed} fieldValue - Value to match against
	 * @param {Mixed} exprValue - Operator expression, or exact match value
	 * @return {Boolean} - Whether or not the operator expression matches the value
	 */
	_operatorExpressionMatches(fieldValue, exprValue) {
		let exprOperators = this._queryFactory._exprOperators;
		for (let exprOperatorKey in exprValue) {
			let operatorValue = exprValue[exprOperatorKey];
			if (operatorValue === undefined) continue;
			let exprOperator = exprOperators[exprOperatorKey];
			if (!exprOperator) {
				throw new QueryValidationError('Unrecognized expression operator: ' + exprOperator);
			}
			if (!exprOperator.matches(fieldValue, operatorValue, exprOperatorKey, exprValue, this)) {
				return false;
			}
		}
		return true;
	}

	/**
	 * Executes a match of a subquery in the context of this query.
	 *
	 * @method _matchSubquery
	 * @private
	 * @param {Mixed} subqueryData - Data to create subquery with
	 * @param {Mixed} value - Value to match against
	 * @return {Boolean} - Does it match?
	 */
	_matchSubquery(subqueryData, value) {
		let subquery = this._queryFactory.createQuery(subqueryData);
		let doesItMatch = subquery.matches(value);
		this._mergeMatchProperties(subquery);
		return doesItMatch;
	}

	/**
	 * Returns a function that takes a value as a parameter and matches the query
	 * against the given value.  Right now, there is no real difference between using
	 * this and just calling match() on each value, but in the future, this may return
	 * a precompiled function that is able to do much faster matching.
	 *
	 * @method createMatchingFn
	 * @return {Function} - Function in the form function(value) which returns a boolean.
	 */
	createMatchingFn() {
		return (value => this.matches(value));
	}

	/**
	 * Internal function to traverse a query tree.
	 *
	 * @method _traverse
	 * @private
	 * @param {Object} handlers - Set of handler functions for query entities.  Each of these
	 * is called with a 'this' pointer of the relevant operator.  Any of these functions can
	 * return a boolean 'false' to prevent recursive traversal into the respective entity.
	 *   @param {Function} handlers.queryOperator - Called for each query operator
	 *     @param {Mixed} handlers.queryOperator.exprValue - Value of the query operator key
	 *     @param {String} handlers.queryOperator.operator - String name of the operator
	 *     @param {Query} handlers.queryOperator.query - This query
	 *   @param {Function} handlers.exprOperator - Called for each expression operator
	 *     @param {Mixed} handlers.exprOperator.exprValue - Value of the expression operator key
	 *     @param {String} handlers.exprOperator.field - Field expr operator applied to, or null (if at root)
	 *     @param {String} handlers.exprOperator.operator - String name of the operator
	 *     @param {Object} handlers.exprOperator.expr - The containing expression of the expression operator
	 *     @param {Query} handlers.exprOperator.query - This query
	 *   @param {Function} handlers.exactMatch - Function called for each exact match (called without a 'this')
	 *     @param {Mixed} handlers.exactMatch.value - Exact match value
	 *     @param {String} handlers.exactMatch.field - Exact match field
	 *   @param {Function} handlers.query - Function that is called for the main query and any subqueries
	 *     @param {Query} handlers.query.query - Query object for query or subquery
	 */
	_traverse(handlers) {
		let query = this._queryData;
		let queryOperators = this._queryFactory._queryOperators;
		let exprOperators = this._queryFactory._exprOperators;
		let traverseRet = handlers.query(this);
		if (traverseRet === false) return;
		if (!_.isPlainObject(query)) throw new QueryValidationError('Query must be a plain object');
		for (let key in query) {
			let exprValue = query[key];
			if (exprValue === undefined) continue;
			if (key[0] === '$') {
				// This key is a query operator or expression operator
				let queryOperator = queryOperators[key];
				if (queryOperator) {
					let fieldWithPrefix = this._fieldPrefix ? (this._fieldPrefix + '.' + key) : key;
					let traverseRet = handlers.queryOperator.call(queryOperator, exprValue, fieldWithPrefix, this);
					if (traverseRet !== false) {
						queryOperator.traverse(exprValue, fieldWithPrefix, this, handlers);
					}
				} else {
					let exprOperator = exprOperators[key];
					if (exprOperator) {
						let traverseRet = handlers.exprOperator.call(exprOperator, exprValue, null, key, query, this);
						if (traverseRet !== false) {
							exprOperator.traverse(exprValue, null, key, query, this, handlers);
						}
					} else {
						throw new QueryValidationError('Unrecognized query operator: ' + key);
					}
				}
			} else {
				// This key is a field name
				let fieldWithPrefix = this._fieldPrefix ? (this._fieldPrefix + '.' + key) : key;
				this._traverseExpressionValue(exprValue, fieldWithPrefix, handlers);
			}
		}
	}

	_traverseExpressionValue(exprValue, field, handlers) {
		if (isOperatorExpression(exprValue)) {
			// Query expression is a set of expression operators
			this._traverseOperatorExpression(exprValue, field, handlers);
		} else {
			// It's an exact match
			handlers.exactMatch.call(null, exprValue, field);
		}
	}

	_traverseOperatorExpression(exprValue, field, handlers) {
		let exprOperators = this._queryFactory._exprOperators;
		for (let exprOperatorKey in exprValue) {
			let operatorValue = exprValue[exprOperatorKey];
			if (operatorValue === undefined) continue;
			let exprOperator = exprOperators[exprOperatorKey];
			if (!exprOperator) {
				throw new QueryValidationError('Unrecognized expression operator: ' + exprOperatorKey);
			}
			let traverseRet = handlers.exprOperator.call(
				exprOperator,
				operatorValue,
				field,
				exprOperatorKey,
				exprValue,
				this
			);
			if (traverseRet !== false) {
				exprOperator.traverse(operatorValue, field, exprOperatorKey, exprValue, this, handlers);
			}
		}
	}

	_traverseSubquery(subqueryData, handlers, fieldPrefix) {
		let subquery = this._queryFactory.createQuery(subqueryData);
		subquery._fieldPrefix = fieldPrefix || this._fieldPrefix;
		subquery._traverse(handlers);
	}

	/**
	 * Validates that the encapsulated query is correct.
	 *
	 * @method validate
	 * @throws {XError} - Validation error
	 * @return {Boolean} - true
	 */
	validate() {
		this._traverse({
			queryOperator(exprValue, operator, query) {
				this.validate(exprValue, operator, query);
			},
			exprOperator(exprValue, field, operator, expr, query) {
				this.validate(exprValue, operator, expr, query);
			},
			exactMatch: _.noop,
			query: _.noop
		});
		return true;
	}

	/**
	 * Returns a list of fields (in dot-separated notation) that the query accesses.
	 *
	 * @method getQueriedFields
	 * @throws {XError} - Validation error
	 * @return {String[]} - Array of fields
	 */
	getQueriedFields() {
		let fieldSet = {};
		let exprOperators = this._queryFactory._exprOperators;
		this._traverse({
			queryOperator: _.noop,
			exprOperator(exprValue, field, operator/*, expr, query*/) {
				let exprOperator = exprOperators[operator];
				if (!exprOperator.ignoreQueriedField && field !== null && field !== undefined) {
					fieldSet[field] = true;
				}
			},
			exactMatch(value, field) {
				if (field !== null && field !== undefined) {
					fieldSet[field] = true;
				}
			},
			query: _.noop
		});
		return _.keys(fieldSet);
	}

	/**
	 * Transforms queried fields according to a given transformation function.  Changes
	 * are made in-place.
	 *
	 * @method transformQueriedFields
	 * @throws {XError} - Validation error
	 * @param {Function} transformFn - Function that takes a field name and returns a
	 * transformed field name.
	 * @param {String} transformFn.name - Field name
	 */
	transformQueriedFields(transformFn) {
		let queryOperators = this._queryFactory._queryOperators;
		let exprOperators = this._queryFactory._exprOperators;
		this._traverse({
			queryOperator(exprValue, operator/*, query*/) {
				let queryOperator = queryOperators[operator];
				if (queryOperator.newQueryContext) {
					return false;
				}
			},
			exprOperator(exprValue, field, operator/*, expr, query*/) {
				let exprOperator = exprOperators[operator];
				if (exprOperator.newQueryContext) {
					return false;
				}
			},
			exactMatch: _.noop,
			query(query) {
				query = query.getData();
				let transformMap = {};
				for (let key in query) {
					if (key[0] !== '$') {
						let newKey = transformFn(key);
						if (newKey !== key) {
							transformMap[key] = newKey;
						}
					}
				}
				for (let key in transformMap) {
					query[transformMap[key]] = query[key];
					delete query[key];
				}
			}
		});
	}

	/**
	 * Returns information on exactly matched fields in the query.  Exactly matched fields
	 * are fields that must match a single, exact, scalar, non-null value for the query
	 * to match.  This function also returns a boolean that indicates whether there are
	 * any fields in the query that are not exact matches.
	 *
	 * If the query can never match (ie, { $or: [] } ), an empty object is returned for
	 * exactMatches and onlyExactMatches is set to false.
	 *
	 * @method getExactMatches
	 * @throws {XError} - Validation error
	 * @return {Object} - Object in the form: `{ exactMatches: {...}, onlyExactMatches: true|false }`
	 */
	getExactMatches() {
		let hasNonExactMatches = false;
		let canNeverMatch = false;
		let exactMatches = {};
		let conflictingMatches = [];

		function addQueryExactMatches(query) {
			for (let key in query) {
				if (key === '$and') {
					// Recursively traverse nested $and queries
					if (!Array.isArray(query[key])) throw new QueryValidationError('Operand to $and must be array');
					for (let subquery of query[key]) {
						addQueryExactMatches(subquery);
					}
				} else if (key === '$or') {
					// A $or can only be an unconditional exact match if it only has a single subquery
					if (!Array.isArray(query[key])) throw new QueryValidationError('Operand to $or must be array');
					if (query[key].length === 0) {
						canNeverMatch = true;
					} else if (query[key].length === 1) {
						addQueryExactMatches(query[key][0]);
					} else {
						hasNonExactMatches = true;
					}
				} else if (key[0] === '$') {
					// Any other query operator ($or or $nor) counts as a non-exact match
					hasNonExactMatches = true;
				} else if (isOperatorExpression(query[key])) {
					// Operators in the value indicate a non-exact match
					hasNonExactMatches = true;
				} else {
					// The value is an exact match
					if (exactMatches[key] !== undefined && !objtools.deepEquals(exactMatches[key], query[key])) {
						// Conflicting exact matches for the same field; the query will only match if the
						// field in the document is an array with both values.  We don't handle that here,
						// so handle it as a non-exact match.
						hasNonExactMatches = true;
						conflictingMatches.push(key);
					} else {
						exactMatches[key] = query[key];
					}
				}
			}
		}

		addQueryExactMatches(this._queryData);

		for (let conflictingMatch of conflictingMatches) {
			delete exactMatches[conflictingMatch];
		}

		if (canNeverMatch) {
			return {
				exactMatches: {},
				onlyExactMatches: false
			};
		} else {
			return {
				exactMatches,
				onlyExactMatches: !hasNonExactMatches
			};
		}
	}

	/**
	 * Returns a list of all operators used in the query.
	 *
	 * @method getOperators
	 * @throws {XError} - Validation error
	 * @return {String[]} - Array of all operators, such as `[ "$and", "$in" ]`
	 */
	getOperators() {
		let operatorSet = {};
		this._traverse({
			queryOperator(exprValue, operator) {
				operatorSet[operator] = true;
			},
			exprOperator(exprValue, field, operator) {
				operatorSet[operator] = true;
			},
			exactMatch: _.noop,
			query: _.noop
		});
		return Object.keys(operatorSet);
	}

	/**
	 * Substitutes $var expressions in the query with their corresponding values
	 * given as the parameter.  Substitution is done in-place.
	 *
	 * @method substituteVars
	 * @private
	 * @throws {XError} - Validation error, or missing var error
	 * @param {Object} vars - Mapping from variable names to values
	 * @param {Boolean} ignoreMissing - If set to true, exceptions are not thrown if
	 * a missing var name is encountered.
	 */
	_substituteVars(vars, ignoreMissing) {

		function subst(obj) {
			if (isVarExpression(obj)) {
				let varName = obj.$var;
				if (vars[varName] === undefined) {
					if (ignoreMissing) {
						return null;
					} else {
						throw new MissingQueryVarError(varName);
					}
				} else {
					return vars[varName];
				}
			} else if (Array.isArray(obj)) {
				return _.map(obj, subst);
			} else if (_.isPlainObject(obj)) {
				for (let key in obj) {
					obj[key] = subst(obj[key]);
				}
				return obj;
			} else {
				return obj;
			}
		}

		this._queryData = subst(this._queryData);
	}

}

module.exports = Query;

/**
 * Helper function to determine if a given expression is an operator expression in the
 * form { $gt: 12, $lt: 15 } or is an exact match.
 *
 * @param {Mixed} expr
 * @throws {XError} - Throws if expression is a mix of operators and non-operators
 * @return {Boolean} - True if expression contains operators
 */
function isOperatorExpression(expr) {
	let hasOperators = false;
	let hasNonOperators = false;
	for (let key in expr) {
		if (key[0] === '$') {
			hasOperators = true;
		} else {
			hasNonOperators = true;
		}
	}
	if (hasOperators && hasNonOperators) {
		throw new QueryValidationError('Expressions may not contain a mix of operators and non-operators');
	}
	return hasOperators;
}

/**
 * Determines if the expression is a variable substitution expression (for substituting a scalar value)
 * in the form of { $var: "VARNAME" }
*/
function isVarExpression(expr) {
	return !!(
		expr &&
		_.isPlainObject(expr) &&
		Object.keys(expr).length === 1 &&
		_.isString(expr.$var)
	);
}
